<!doctype html>
<html lang="en">

<head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Bootstrap CSS -->
    <!-- <link rel="stylesheet" type="text/css" href="../../_css/bootstrap.css"> -->
    <link rel="stylesheet" type="text/css" href="../../../_css/style.css">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <title>Promises and Fetch</title>
</head>

<body>
    <div id="breadcrumb-container">

        <span id="breadcrumb-homepage">
      <a href="../../index.html">Home page</a>
    </span>
        <span class="breadcrumb-link">Promises and Fetch</span>
    </div>
    <div id="auto-toc"></div>




    <h1>Promises</h1>

    <h2>Overview</h2>
    <div class="text-section">
        <h5>Definitions of a Promise</h5>

        <ol>
            <li>A Promise is an <span class="text-object">Object</span> that is used as a <span class="text-object">placeholder</span> for the <span class="text-object">future result</span> of an <span class="text-object">Asynchronous</span> operation.
            </li>
            <li>A Promise is a proxy for a value that will eventually become available.</li>
        </ol>

        <h5>Purpose</h5>
        <p>You no longer need to rely on events and callback functions to handle Asynchronous results.
        </p>
        <p>Also, you can chain them (instead of nesting) which escapes callback hell.</p>

        <h5>Async functions</h5>
        <p>Async functions use Promises behind the scenes, so understanding Promises is fundamental to understanding how Async/Await works.</p>

        <h3>Links</h3>
        <ul>
            <li><a href="https://nodejs.dev/learn/understanding-javascript-promises" target="_blank">Understanding
          Promises</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank">MDM: Promises</a></li>
            <li><a href="https://www.w3schools.com/js/js_promise.asp" target="_blank">W3Schools: Promises</a></li>
        </ul>



    </div>




    <h2>Promise Lifecycle</h2>
    <div class="text-section">
        <p>Promises are time sensitive and change over time because they work with Asynchronous operations. This is called the lifecycle.</p>
        <img src="../../_img/promise-lifecycle.png" width="950px">
    </div>


    <h3>Pending</h3>
    <div class="text-section">

        <p>Promise start in a pending state.</p>
        <p>This is before any value resulting from the Asynchronous task is available.</p>
        <p>During this time, the Asynchronous task (calling function) continues executing in the background.</p>
    </div>



    <h3>Settled</h3>
    <div class="text-section">
        <p>When the task finally finishes, the Promise is <span class="text-object">Settled</span>.</p>
        <p>There are two different types of Settled Promises.</p>
        <ul>
            <li>Fulfilled (Resolved)</li>
            <li>Rejected</li>
        </ul>

        <h5>Fulfilled (Resolved)</h5>
        <p>A Fulfilled Promise has successfully resulted in a value that's available to be used.</p>
        <p>This gives the calling function the data that was requested.</p>

        <h5>Rejected</h5>
        <p>Rejected: a rejected promise means that there has been an error during the asynchronous task.</p>


        <h5>After it finishes</h5>
        <p>After the Promise finishes, it calls the callback functions (passed to then and catch).</p>
        <p>A Promise is only settled once as Fulfilled or Rejected. It's impossible to change the state after it finishes.
        </p>

    </div>




    <h3>Consume a Promise (Using it)</h3>
    <div class="text-section">
        <p>Consuming a Promise is when it returns a result.</p>
        <p>But in order for a promise to exist in the first place, it must first be built. So it must be created in the case of the fetch API, it's the fetch function that builds the promise and returns it for us to consume.</p>


    </div>




    <h2>APIs that use Promises</h2>
    <div class="text-section">
        <p>Promises are used by standard modern Web APIs such as:</p>
        <ul>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API" target="_blank">Battery API</a>
            </li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" target="_blank">Fetch API</a></li>
            <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API" target="_blank">Service
          Workers</a></li>
        </ul>
    </div>
























    <h1>Promise architecture</h1>
    <h2>The Promise Constructor</h2>
    <section class="code-section-container">
        <div class="code-text-section">
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise" target="_blank">The Promise Constructor</a></li>
            </ul>
            <p>The Promise constructor is primarily used to wrap functions that do not already support promises.</p>
            <p>This example builds a Promise named <span class="code">myPromise</span> using the <span class="code">new
          Promise()</span> constructor.</p>

        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">let <span class="code-highlight-js">myPromise</span> = <span class="code-highlight-js">new Promise()</span></span></pre>
        </div>
    </section>


    <h2>The Executor parameter</h2>
    <section class="code-section-container">
        <div class="code-text-section">

            <p>The Promise Constuctor takes in an Executor parameter.</p>
            <p>This is a function to be executed by the constructor.</p>
            <p>The Executor is the developers custom code.</p>

        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">let myPromise = new Promise<span class="code-highlight-js">(function() </span>{
  <span class="code-comment">executor code here</span>
}</pre>
        </div>
    </section>


    <h2>Executor functions</h2>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>Two functions are passed in to the Executor.</p>
            <ul>
                <li> The first for when the Promise resolves.</li>
                <li> The second for when it is rejected.</li>
            </ul>
            <p>You can name these anything you want. They are usually <span class="code">resolve, reject</span>. This example uses <span class="code">myResolve, myReject</span></p>
            <p>At the time when the constructor generates the new Promise object, it also generates a corresponding pair of functions to resolve or reject; these are "tethered" to the Promise object.</p>

        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">let myPromise = new Promise(function<span class="code-highlight-js">(myResolve, myReject)</span> {
  <span class="code-comment">executor code here</span>
}</pre>
        </div>
    </section>




    <h2>The Return value</h2>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>The Promise constructor returns a Promise Object.</p>
            <img src="../../_img/fetch-response.png" width="250px">
            <p>The Promise Object is "resolved" when either of the Executor functions (resolve or reject) are invoked.</p>
            <div class="notebox-note">
                <p>The Promise returns a value, but you cannot see it unless you use the <span class="code">then()</span> method.
                </p>
            </div>

        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">let myPromise = new Promise(function(myResolve, myReject) {
    let x = 0;

    if (x == 0) {
      <span class="code-highlight-js">myResolve("OK");</span>
    } else {
      <span class="code-highlight-js">myReject("Error");</span>
    }
  });
}</pre>
        </div>
    </section>



    <h2>View the result of the Promise</h2>
    <section class="code-section-container">
        <div class="code-text-section">



            <p>The Promise returns a value, but you cannot see it unless you use the <span class="code">then()</span> method.
            </p>
            <ul>
                <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/then" target="_blank">then()</a></li>
            </ul>
            <p>The <span class="code">then()</span> method returns a Promise.</p>
            <p>It takes up to two arguments:</p>
            <ul>
                <li>A callback function for the <span class="text-object">success</span> of the Promise.</li>
                <li>A callback function for the <span class="text-object">failure</span> of the Promise.</li>
            </ul>
            <div class="notebox-note">
                <p>Both are optional, so you can add a callback for success or failure only.</p>
            </div>




        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">let myPromise = new Promise(function(myResolve, myReject) {
  let x = 0;

  if (x == 0) {
    myResolve("OK");
  } else {
    myReject("Error");
  }
});

myPromise.<span class="code-highlight-js">then(function(value) {
    console.log(value)
  },
  function(error) {
    console.log(error)
  }
);</span></pre>
        </div>
    </section>















    <h1>Example of a Promise</h1>



    <section class="code-section-container">
        <div class="code-text-section">
            <ol>
                <li>Build a Promise using the <span class="code">new Promise()</span> constructor.</li>
                <li>It automatically runs the executor function which passes in two other arguments. <span class="code">resolve</span> and <span class="code">reject</span> functions.
                </li>
                <li>Use the <span class="code">then()</span> method to view the result of the Promise Object.</li>
                <p>The <span class="code">then()</span> method returns a Promise.</p>
                <p>It takes up to two arguments:</p>
                <ul>
                    <li>A callback function for the <span class="text-object">success</span> of the Promise.</li>
                    <li>A callback function for the <span class="text-object">failure</span> of the Promise.</li>
                </ul>
            </ol>


            <p>Reload the page to see the WIN or LOSE result.</p>

        </div>



        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const lotteryPromise = new Promise(function(resolve, reject) {

if (Math.random() >= 0.5) {
  <span class="code-comment">// The value passed into the resolve function 
  // wil be the result of the promise
  // It will be available using the then() handler. </span>
  resolve('You WIN')
}
else {
  <span class="code-comment">// pass in error message to be available in catch() </span>
  reject('You lost your money.')
}
})

<span class="code-comment">// lotteryPromise is Promise Object at this point.
// Use the then() method to view the result of the Promise Object
// the then() method needs a callback function that is going to be called
// with the resolved value of the promise.
// res can be any name
// .catch any errors </span>
lotteryPromise.then(res => console.log(res)).catch(err => console.error(err))</span></pre>
        </div>
    </section>









    <h1>Fetch</h1>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>The Fetch API is a promise-based mechanism, and calling fetch() is equivalent to defining our own promise using new Promise().</p>




            <p>Project example:</p>
            <ul>
                <li><a href="project/index.html" target="_blank">Example project</a></li>
            </ul>
            <p>In these examples, the <a href="https://restcountries.com/">restcountries.com</a> API is used.</p>

            <p>This is a very basic fetch function call to a URL.</p>
            <p>Fetch returns a promise.</p>
            <img src="../../_img/fetch-response.png" width="250px">
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const request = fetch('https://restcountries.com/v2/name/portugal')
console.log(request)</span></pre>
        </div>
    </section>





    <h1>Consuming Promises</h1>

    <section class="code-section-container">
        <div class="code-text-section">
            <p>This is a basic fetch function call to a URL which returns a promise.</p>
            <ol>
                <li>Use the Fetch API to create a Promise.</li>
                <li><span class="code">.then()</span> is used to handle this first Promise. </li>
                <li>Pass in a callback function to be executed as soon as the Promise is fulfilled. This is <span class="code">(function (response)</span>.</li>
                <li>This function receives 1 arg once it's called by JavaScript. That argument is the resulting value of the fulfilled promise. In this example it's named <span class="code">response</span>. It returns the response Object.
                </li>
                <li>The response Object contains a <span class="code">body</span> property, but the <span class="code">body</span> property cannot be read.
                    <p><img src="../../_img/promise-body.png" width="450px"></p>
                </li>
                <li>To read the <span class="code">body</span> property, you must the <span class="code">json()</span> method on the response Object. </li>
                <li><span class="code">json()</span> also returns a new Promise, so you must return it here and handle it.</li>
                <li>Use <span class="code">then()</span> again on this 2nd Promise. This <span class="code">then()</span> is a callback function to handle the <span class="code">json()</span> Promise data. This time, the data is returned because the resolved
                    value of this Promise is the data itself.</li>
                <li>Use <span class="code">data.name</span> which is a property of the API data returned.</p>
            </ol>

            </p>
        </div>



        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const renderCountry = function(data) {
  console.log(<span class="code-highlight-js">data.name</span>)
};
    
  const getCountryData = function (country) {

  <span class="code-highlight-js">fetch</span>(`https://restcountries.com/v2/name/${country}`)  
  <span class="code-highlight-js">.then(function (response)</span> {
    console.log(response)
    return response.<span class="code-highlight-js">json()</span>;
  })
  <span class="code-highlight-js">.then(function (data)</span> {
    renderCountry(data[0]);
  });
};

getCountryData('portugal');</span></pre>
        </div>
    </section>












    <h2>Simplified using Arrow Functions</h2>

    <section class="code-section-container">
        <div class="code-text-section">
            <p>This is the same as above but uses Arrow Functions.</p>
            <p>This fetches something and then we get a response which will be transformed to json. And then we take that data and render the country to the DOM.</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const renderCountry = function(data) {
  console.log(data.name)
};

const getCountryData = function(country) {
  fetch(`https://restcountries.com/v2/name/${country}`)
      .then(<span class="code-highlight-js">response => response.json()</span>)
      .then(<span class="code-highlight-js">data => renderCountry(data[0])</span>);
};

getCountryData('portugal');</span></pre>
        </div>
    </section>











    <h1>Chaining Promises</h1>
    <h2>Overview</h2>
    <div class="text-section">
        <p>A Promise can be returned to another Promise, creating a chain of Promises.</p>
        <p>In this way, you can execute two or more asynchronous operations back to back, where each subsequent operation starts when the previous operation succeeds, with the result from the previous step.</p>
        <p>The <span class="code">then()</span> method returns a new Promise, different from the original.</p>
        <p>Each Promise represents the completion of another asynchronous step in the chain.</p>
    </div>




    <h2>Chaining Syntax</h2>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>This shows the idea of how chaining works.</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">doSomething()
<span class="code-highlight-js">.then</span>(function(result) {
  return doSomethingElse(result);
})
<span class="code-highlight-js">.then</span>(function(newResult) {
  return doThirdThing(newResult);
})
<span class="code-highlight-js">.then</span>(function(finalResult) {
  console.log('Got the final result: ' + finalResult);
})
<span class="code-highlight-js">.catch</span>(failureCallback);</span></pre>
        </div>
    </section>


    <h2>Chaining exmaple #1</h2>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>This creates a function named <span class="code">numberValue</span>.</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">let <span class="code-highlight-js">numberValue</span> = new Promise(function(resolve, reject) {
    const product = 2;
    resolve(product);
});

numberValue
    <span class="code-highlight-js">.then</span>(function successValue(product) {
      console.log(product);
      return product * 2;
    })
    <span class="code-highlight-js">.then</span>(function successValue1(product) {
      console.log(product);
      return product * 4;
    })
    <span class="code-highlight-js">.then</span>(function successValue2(product) {
      console.log(product);
      return product * 6;
});</span></pre>
        </div>
    </section>

    <section class="code-section-container">
        <div class="code-text-section">
            <p>Output</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="output">2
4
16</span></pre>
        </div>
    </section>









    <h2>Chaining example #2</h2>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>This example uses the <span class="code">setTimeout()</span> function to create Async behavior.</p>
            <p>Create three functions that return a Promise.</p>
            <p>Chain all of them together using <span class="code">then()</span>.</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">function getUser(userId) {
  return new Promise((resolve, reject) => {
      console.log('Get the user from the database.');
      setTimeout(() => {
          resolve({
              userId: userId,
              username: 'admin'
          });
      }, 1000);
  })
}

function getServices(user) {
  return new Promise((resolve, reject) => {
      console.log(`Get the services of user# ${user.userId} with the username of ${user.username} from the API.`);
      setTimeout(() => {
          resolve(['Email', 'VPN', 'CDN']);
      }, 3 * 1000);
  });
}

function getServiceCost(services) {
  return new Promise((resolve, reject) => {
      console.log(`Calculate the service cost of ${services}.`);
      setTimeout(() => {
          resolve(services.length * 100);
      }, 2 * 1000);
  });
}

<span class="code-comment">// Chaining</span>
<span class="code-highlight-js">getUser(100)
  .then(getServices)
  .then(getServiceCost)
  .then(console.log);</spasn></span></pre>
        </div>
    </section>

    <section class="code-section-container">
        <div class="code-text-section">
            <p>Output</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="output">Get the user from the database.
Get the services of user# 100 with the username of admin from the API.
Calculate the service cost of Email,VPN,CDN.
300</span></pre>
        </div>
    </section>








    <h2>Chaining example #3</h2>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>This chains an additional fetch call based off the first fetch call.</p>
            <p>The avoids callback hell by returning the promise and handling it outside by continuing the chain using .then().
            </p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const renderCountry = function(data) {
  console.log(data.name)
};

const getCountryData = function(country) {
  fetch(`https://restcountries.com/v2/name/${country}`)
      <span class="code-comment">// return the response body using json()</span>
      .then(response => response.json())
      .then(data => {
        <span class="code-comment">// data[0] is the only line from the API that contains information </span>                   
          renderCountry(data[0]);
          <span class="code-comment">// borders is the neighbor country from the API</span>
          const neighbour = data[0].borders[0];

          if (!neighbour) return;

          <span class="code-comment">// 2nd AJAX call
          // you must return this promise so you can chain a then method</span>
          return fetch(`https://restcountries.com/v2/alpha/${neighbour}`);
      })
      <span class="code-comment">// this is the fullfilled value from the fetch promise </span>
      .then(response => response.json())
      .then(data => renderCountry(data, 'neighbour'));
};
getCountryData('portugal');</span></pre>
        </div>
    </section>

    <section class="code-section-container">
        <div class="code-text-section">
            <p>Output</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="output">Portugal 
Spain</span></pre>
        </div>
    </section>










    <h1>finally() method</h1>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>The callback function you add to <span class="code">finally()</span> is always called, even if it's rejected.
            </p>
            <p>Use when something always needs to happen with the Promise.</p>
            <p>A common use is hiding a rotating loading spinner.</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const renderError = function (msg) {
countriesContainer.insertAdjacentText('beforeend', msg);
countriesContainer.style.opacity = 1;
};


const getCountryData = function (country) {
fetch(`https://restcountries.com/v2/name/${country}`)
.then(response => response.json())    
.then(data => {
renderCountry(data[0]);
const neighbour = data[0].borders[0];

if (!neighbour) return;

return fetch(`https://restcountries.com/v2/alpha/${neighbour}`);
}) 
.then(response => response.json())
.then(data => renderCountry(data, 'neighbour'))
.catch(err => {
console.error(`${err} üí•üí•üí•`);
renderError(`Something went wrong üí•üí• ${err.message}. Try again!`);
})
<span class="code-highlight-js">.finally(() => {
countriesContainer.style.opacity = 1;
}); </span>
};</span></pre>
        </div>
    </section>















    <h1>Catch</h1>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>When a Promise rejects, the control jumps to the closest <span class="code">catch()</span> rejection handler.
            </p>
            <p><span class="code">.catch</span> doesn‚Äôt have to be immediate. It may appear after one or maybe several <span class="code">.then()</span> methods.</p>
            <p> The easiest way to catch all errors is to append <span class="code">.catch</span> to the end of the chain.</p>
            <p>In this cample, <span class="code">.jsonn</span> is misspelled.</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">fetch('https://jsonplaceholder.typicode.com/users')
.then(function(response) {
  return response.json();
})
<span class="code-comment">// .then(response =&gt; response.json())</span>
.then(user =&gt; fetch(`https://jsonplaceholder.typicode.com/comments`))
.then(function(response) {
  return response.<span class="code-highlight-js">jsonn()</span>;
})
<span class="code-comment">// .then(response =&gt; response.json())</span>
.then(githubUser =&gt; new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
      console.log("setTimeout() block")
      resolve(githubUser);
  }, 3000)

}))
.catch(error =&gt; console.log("Error is: " + error.message));</span></pre>
        </div>
    </section>

    <section class="code-section-container">
        <div class="code-text-section">
            <h6>Output</h6>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-nodejs">Error is: response.jsonn is not a function</span></pre>
        </div>
    </section>






    <h2>Handling rejected Promises</h2>






    <h2>Uncaught (in promise) TypeError: Failed to fetch</h2>

    <div class="text-section">
        <p>This error happens when fetch failed.</p>
        <p>2 ways to avoid this.</p>
    </div>


    <h3>Option 1: Pass 2nd callback function into the first then()</h3>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>The first callback function (then() method) is called for the fullfilled promise.</p>
            <p>Add a 2nd callback when it's rejected.</p>
            <p>This uses err to catch the error.</p>
            <p>The chain then stops at this error.</p>
            <p>The problem is you would have to add this to each fetch call when is a lot of duplicated code.</p>

        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const getCountryData = function (country) {
fetch(`https://restcountries.com/v2/name/${country}`)
  .then(response => response.json()<span class="code-highlight-js">, 
  err => alert(err) </span>
  )    
  .then(data => {
    renderCountry(data[0]);
    const neighbour = data[0].borders[0];

    if (!neighbour) return;

    return fetch(`https://restcountries.com/v2/alpha/${neighbour}`);
  }) 
  .then(response => response.json())
  .then(data => renderCountry(data, 'neighbour'));
};</span></pre>
        </div>
    </section>













    <h3>Option 2: use catch to create global error handling</h3>
    <section class="code-section-container">
        <div class="code-text-section">
            <p>Instead of writing err for each call, add catch to the last method.</p>
            <p>Adding catch to the end catches any errors at any point in the chain.</p>
        </div>
        <div class="code-block-section-w60">
            <pre class="example"><span class="code-js">const getCountryData = function (country) {
fetch(`https://restcountries.com/v2/name/${country}`)
  // 2nd call depends on data from 1st call
  .then(response => response.json())    
  .then(data => {
    // get data then get neighbor country and perform AJAX call
    renderCountry(data[0]);
    const neighbour = data[0].borders[0];

    if (!neighbour) return;

    // 2nd AJAX call
    // you must return this promise so you can chain an then method
    // the then method always returns a promise, even if nothing is returned
    return fetch(`https://restcountries.com/v2/alpha/${neighbour}`);
  }) 
  // this is the fullfilled value from the fetch promise
  .then(response => response.json())
  .then(data => renderCountry(data, 'neighbour'))
  <span class="code-highlight-js">.catch(err = > alert(err)) </span>
};</span></pre>
        </div>
    </section>








    <h2>Display error to page</h3>
        <section class="code-section-container">
            <div class="code-text-section">
                <p>This uses catch to print a message to the page.</p>
            </div>
            <div class="code-block-section-w60">
                <pre class="example"><span class="code-js"><span class="code-comment">// add text to page </span>
<span class="code-highlight-js">const renderError = function (msg) {
  countriesContainer.insertAdjacentText('beforeend', msg);
  countriesContainer.style.opacity = 1;
}; </span>
  
  
  const getCountryData = function (country) {
  fetch(`https://restcountries.com/v2/name/${country}`)
    .then(response => response.json())    
    .then(data => {
      renderCountry(data[0]);
      const neighbour = data[0].borders[0];

      if (!neighbour) return;

      return fetch(`https://restcountries.com/v2/alpha/${neighbour}`);
    }) 
    .then(response => response.json())
    .then(data => renderCountry(data, 'neighbour'))
    <span class="code-highlight-js">.catch(err => {
      renderError(`Something went wrong ${err.message}`);
      })</span>
};</span></pre>
            </div>
        </section>








































        <h1>Manually throw an error</h1>


        <section class="code-section-container">
            <div class="code-text-section">
                <p>Since no country is entered into the getCountryData() function, a 404 error is returned.</p>
                <p>If you consol.log the response, you'll see a property named 'ok' set to false.</p>
                <p>Write an if statement to check if it's false.</p>
                <p>If so, throw a custom error response.</p>
                <p>The problem with this is that if you want to also create a custom error response for the 2nd Promise, you'll have to duplicate the code.</p>
            </div>
            <div class="code-block-section-w60">
                <pre class="example"><span class="code-js">const getCountryData = function (country) {
fetch(`https://restcountries.com/v2/name/${country}`)
<span class="code-highlight-js">.then(response => {
  <span class="code-comment">// log the response error </span>
  console.log(response)
  <span class="code-comment">// ok is a property of the response which you can view using console.log
  // this checks if this ok property is set to false </span>
  if (!response.ok)
  <span class="code-comment">// throw and define a new Error message
  // throw immediately terminates the function, causing the Promise to be rejected
  // this rejection then propagates down to .catch </span>
  throw new Error(`Country not found (${response.status})`);
  return response.json()
}) </span>
.then(data => {
  renderCountry(data[0]);
  const neighbour = data[0].borders[0];

  if (!neighbour) return;

  return fetch(`https://restcountries.com/v2/alpha/${neighbour}`);
}) 
.then(response => response.json())
.then(data => renderCountry(data, 'neighbour'))
.catch(err => {
  console.error(`${err}`);
  renderError(`Something went wrong ${err.message}`);
  })
  .finally(() => {
    countriesContainer.style.opacity = 1;
  })
};

getCountryData('');</span></pre>
            </div>
        </section>







        <h1>Create a helper function to remove code duplication</h1>

        <section class="code-section-container">
            <div class="code-text-section">
                <p>Creating a helper function helps you to avoid creating duplicate code.</p>
                <p>This creates a helper function getJSON() to accept a URL and an error message.</p>
                <p>If the response is ok property is false (meaning the country was not found), an error message is displayed.
                </p>
                <p>Additionally, another if statement is added to check if there's a neighbour country. if not, a custom error displays.
                </p>
            </div>
            <div class="code-block-section-w60">
                <pre class="example"><span class="code-js"><span class="code-comment">// errorMsg has a default error message set as a param
// this function returns a Promise </span>
const getJSON = function (url, errorMsg = 'Something went wrong') {
  return fetch(url).then(response => {
    if (!response.ok) throw new Error(`${errorMsg} (${response.status})`);

    return response.json();
  });
};

const getCountryData = function (country) {
<span class="code-comment">// Country 1 </span>
getJSON(
  `https://restcountries.com/v2/name/${country}`,
  'Country not found'
)
  .then(data => {
    renderCountry(data[0]);

    const neighbour = data[0].borders[0];
    
    <span class="code-comment">// throws an error if no neighbors exist </span>
    if (!neighbour) throw new Error('No neighbour found!');

    <span class="code-comment">// Country 2 </span>
    return getJSON(
      `https://restcountries.com/v2/alpha/${neighbour}`,
      'Country not found'
    );
  })

  .then(data => renderCountry(data, 'neighbour'))
  .catch(err => {
    console.error(`${err} üí•üí•üí•`);
    renderError(`catch: Something went wrong üí•üí• ${err.message}. Try again!`);
  })
  .finally(() => {
    countriesContainer.style.opacity = 1;
  });
};

getCountryData('australia');</span></pre>
            </div>
        </section>










        <h2>Add asynchronous behavior</h1>
            <section class="code-section-container">
                <div class="code-text-section">
                    <p>This uses a timer. This encapsulates asyn behavior into the Promise</p>
                </div>
                <div class="code-block-section-w60">
                    <pre class="example"><span class="code-js">const lotteryPromise = new Promise(function (resolve, reject) {

console.log('Lottery draw is happening')

<span class="code-highlight-js">setTimeout(function () { </span>
  if (Math.random() >= 0.5) {
    resolve('You WIN')
  }
  else {
    <span class="code-comment">// create new Error object </span>
    reject(new Error('You lost your money.'))
  }
<span class="code-highlight-js">}, 2000) </span>
})


lotteryPromise.then(res => console.log(res)).catch(err => console.error(err))</span></pre>
                </div>
            </section>










            <h2>Promisifying</h2>

            <section class="code-section-container">
                <div class="code-text-section">

                    <p>‚ÄúPromisification‚Äù is the conversion of a function that accepts a callback into a function that returns a promise.</p>
                    <p>Many functions and libraries are callback-based. But promises are more convenient, so it makes sense to promisify them.</p>



                    <p>Promisifying is building a Promise to wrap a callback based functions into promises. And this is a process that we call .
                    </p>
                    <p> promisifying means to convert callback based asynchronous behavior to promise based.</p>
                    <p>This promisifies the setTimeout function and creates a wait function</p>

                </div>
                <div class="code-block-section-w60">
                    <pre class="example"><span class="code-js">const lotteryPromise = new Promise(function (resolve, reject) {

  console.log('Lottery draw is happening')

  setTimeout(function () {
    if (Math.random() >= 0.5) {
      resolve('You WIN')
    }
    else {
      <span class="code-comment">// create new Error object </span>
      reject(new Error('You lost your money.'))
    }
  }, 2000)
})


lotteryPromise.then(res => console.log(res)).catch(err => console.error(err))

const wait = function (seconds) {
  <span class="code-comment">// create and return a Promise
  // promisify setTimeout()
  // reject is not needed since the timer cannot fail </span>
  return new Promise(function (resolve) {
    <span class="code-comment">// resolve is the callback function </span>
    setTimeout(resolve, seconds * 1000)
  })
}

<span class="code-comment">// consume the Promise
// there is no resolved value for a timer so then() is empty </span>
wait(2).then(() => {
  console.log('Code to run after 2 seconds')
  <span class="code-comment">// return a new Promise </span>
  return wait(1)
}).then(() => console.log('Waited for 1 second'))</span></pre>
                </div>
            </section>



            <h2>Immediately resolve or reject a Promise</h2>

            <div class="col">
                <pre class="example"><span class="code-js">Promise.resolve('this resolves immediately').then(x => console.log(x))
Promise.reject('this rejects immediately').catch(x => console.log(x)) </span></pre>
            </div>
















            <h1>Consuming Promises with async/await</h1>

            <h2>Overview</h2>
            <div class="text-section">
                <p><span class="text-object">Async/Await</span> is used to make Asynchronous code look more like Synchronous.</p>
                <p>It is thought of "syntactic sugar" over the <span class="code">then()</span> method in Promises.</p>
                <p>Behind the scenes, we are still using Promises. We are simply using a different way of consuming them here
                </p>
                <p>This makes it easier for humans to understand.</p>
            </div>

            <h2>Syntax</h2>
            <section class="code-section-container">
                <div class="code-text-section">
                    <p>This is the basic syntax of <span class="text-object">Async/Await</span>.</p>
                </div>
                <div class="code-block-section-w60"><pre class="example"><span class="code-js"><span class="code-highlight-js">async</span> function myFunction(){
  <span class="code-highlight-js">await</span> printString("one")
  <span class="code-highlight-js">await</span> printString("two")
  <span class="code-highlight-js">await</span> printString("three")
}</span></pre></div>
            </section>




            <h3>async</h3>
            <div class="text-section">

                <p>The <span class="code">async</span> keyword is used to wrap the current function named <span class="code">myFunction</span>.</p>
                <p>Functions must always be wrapped individually. There is no way to do this at the global level.</p>
                <p>You can also think of this as: <span class="code">await</span> is only used with an <span class="text-object">Async</span> function.</p>
                <p><span class="code">async</span> makes a function return a Promise</p>
            </div>

            <h3>await</h3>
            <div class="text-section">
                <p>The <span class="code">await</span> keyword ensures all Promises returned "wait" for each other.</p>

                <p>Await eliminates the use of callbacks in <span class="code">.then()</span> and <span class="code">.catch()</span>.</p>
                <p><span class="code">await</span> makes a function wait for a Promise.</p>
            </div>
            <h3>try/catch</h3>
            <div class="text-section">
                <p><span class="code">try</span> and <span class="code">catch</span> are also used to get the rejection value of an async function.</p>
            </div>









            <h2>Example</h2>


            <div class="text-section">
                <p>This is a function that keeps running in the background while performing the code inside of it</p>
                <p>When finished it returns a Promise</p>
            </div>


            <section class="code-section-container">
                <div class="code-text-section">
                    <ol>
                        <li>Start by creating an <span class="text-object">Async</span> function by adding the <span class="code">async</span> keyword in front of the function name.</li>
                        <li>Inside the funciton, use <span class="code">fetch</span> to create a Promise.</li>
                        <li>Adding <span class="code">await</span> stops the code execution at this point of the function until the Promise is fulfilled.
                            <div class="notebox-note">
                                <p>Stopping execution in an <span class="text-object">Async</span> function is okay because this function is running asynchronously in the background. This means it's not blocking the call stack.</p>
                            </div>
                        </li>
                        <li>When the Promise is resolved, the value of the <span class="code">await</span> expression is going to be the resolved value of the Promise, stored into a variable. You can then call this variable.</li>
                    </ol>
                </div>
                <div class="code-block-section-w60">
                    <pre class="example"><span class="code-js">const whereAmI = <span class="code-highlight-js">async</span> function (country) {
  <span class="code-comment">// inside create await statements that await the result of the Promise </span>                  
  const res = <span class="code-highlight-js">await</span> fetch(`https://restcountries.com/v2/name/${country}`)
  console.log(res)
}

whereAmI()</span></pre>
                </div>
            </section>







            <h1>Combinators
        </h2>

        <h2>race</h2>
        <h2>allSettled</h2>
        <h2>any</h2>










        <script>
            const lotteryPromise = new Promise(function(resolve, reject) {
                console.log('Lottery draw is happening')

                setTimeout(function() {
                    if (Math.random() >= 0.5) {
                        resolve('You WIN')
                    } else {
                        // create new Error object
                        reject(new Error('You lost your money.'))
                    }
                }, 2000)
            })


            lotteryPromise.then(res => console.log(res)).catch(err => console.error(err))

            const wait = function(seconds) {
                // create and return a Promise
                // promisify setTimeout()
                // reject is not needed since the timer cannot fail
                return new Promise(function(resolve) {
                    // resolve is the callback function
                    setTimeout(resolve, seconds * 1000)
                })
            }

            // consume the Promise
            // there is no resolved value for a timer so then() is empty
            wait(2).then(() => {
                console.log('Code to run after 2 seconds')
                    // return a new Promise
                return wait(1)
            }).then(() => console.log('Waited for 1 second'))
        </script>







        <script src="../../../_js/auto-toc.js"></script>
</body>

</html>